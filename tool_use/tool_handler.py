"""Parse and execute tool calls from model output text."""

import json
import re

from tool_use.tools import AVAILABLE_TOOLS

# Matches content between <tool_call> and </tool_call> tags (Qwen2.5 native format)
_TOOL_CALL_PATTERN = re.compile(
    r"<tool_call>\s*(\{.*?\})\s*</tool_call>",
    re.DOTALL,
)


def parse_tool_call(model_output: str) -> tuple[str, dict[str, object]] | None:
    """Extract a tool call from model output text.

    Looks for ``<tool_call>{"name": ..., "arguments": ...}</tool_call>``.

    Args:
        model_output: Raw text generated by the model.

    Returns:
        Tuple of (tool_name, arguments_dict) if valid, None otherwise.
    """
    match = _TOOL_CALL_PATTERN.search(model_output)
    if not match:
        return None

    try:
        call_data = json.loads(match.group(1))
    except json.JSONDecodeError:
        return None

    name = call_data.get("name")
    arguments = call_data.get("arguments", {})

    if not isinstance(name, str) or name not in AVAILABLE_TOOLS:
        return None
    if not isinstance(arguments, dict):
        return None

    return name, arguments


def execute_tool(name: str, arguments: dict[str, object]) -> str:
    """Execute a registered tool and return the result as a JSON string.

    Args:
        name: Tool name (must exist in AVAILABLE_TOOLS).
        arguments: Keyword arguments for the tool function.

    Returns:
        JSON-encoded string of the tool result or error.
    """
    func = AVAILABLE_TOOLS[name]
    try:
        result = func(**arguments)
    except TypeError as exc:
        result = {"error": f"Invalid arguments for '{name}': {exc}"}
    except Exception as exc:
        result = {"error": f"Tool '{name}' failed: {exc}"}

    return json.dumps(result, ensure_ascii=False)


def parse_and_execute_tool_call(model_output: str) -> str | None:
    """Detect, parse, and execute a tool call from model output.

    This is the main entry point used by the inference loop and API.

    Args:
        model_output: Raw text generated by the model.

    Returns:
        JSON string with tool result if a tool was called, None otherwise.
    """
    parsed = parse_tool_call(model_output)
    if parsed is None:
        return None

    name, arguments = parsed
    return execute_tool(name, arguments)
